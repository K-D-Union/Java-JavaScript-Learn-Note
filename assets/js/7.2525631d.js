(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{210:function(t,a,s){"use strict";s.r(a);var e=s(17),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",[t._v("MQ整合")]),t._v(" "),s("h2",{attrs:{id:"消息队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),s("p",[t._v("        消息队列也被称之为MQ，消息队列并不是什么高端的技术，只是微服务架构中的，解决应用的解耦、异步消息、流量削峰、消息分发的一个中间件；什么是消息队列呢？消息应该都理解是什么，队列呢，队列是大家在银行办理业务时人多了需要排队是一个概念，这也就不难理解消息队列了（可以理解成在排队的消息，并且里面有多个窗口）。\n"),s("img",{attrs:{src:t.$withBase("/imgs/clipboard.png"),alt:"clipboard"}})]),t._v(" "),s("h2",{attrs:{id:"消息队列的组成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息队列的组成"}},[t._v("#")]),t._v(" 消息队列的组成")]),t._v(" "),s("h3",{attrs:{id:"broker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#broker"}},[t._v("#")]),t._v(" Broker")]),t._v(" "),s("p",[t._v("        消息服务器，作为server提供消息核心服务")]),t._v(" "),s("h3",{attrs:{id:"producer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#producer"}},[t._v("#")]),t._v(" Producer")]),t._v(" "),s("p",[t._v("        消息生产者，业务的发起方，负责生产消息传输给broker，")]),t._v(" "),s("h3",{attrs:{id:"consumer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consumer"}},[t._v("#")]),t._v(" Consumer")]),t._v(" "),s("p",[t._v("        消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理")]),t._v(" "),s("h3",{attrs:{id:"topic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[t._v("#")]),t._v(" Topic")]),t._v(" "),s("p",[t._v("        主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的       广播")]),t._v(" "),s("h3",{attrs:{id:"queue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[t._v("#")]),t._v(" Queue")]),t._v(" "),s("p",[t._v("        队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收")]),t._v(" "),s("h3",{attrs:{id:"message"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#message"}},[t._v("#")]),t._v(" Message")]),t._v(" "),s("p",[t._v("        消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输")]),t._v(" "),s("h2",{attrs:{id:"应用解耦"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用解耦"}},[t._v("#")]),t._v(" 应用解耦")]),t._v(" "),s("p",[t._v("        以微服务中的订单系统，支付系统、库存系统为例，三个代表每个系统模块的微服务，当\n用户下完订单后，需要告诉支付系统有用户已下单--\x3e需要付款、需要减少库存等操作；如果耦合调用的话，当其中任何一个环节出现了问题，可能需要几分钟才能修复，都会订单失败，会导致服务在这段未修复的时间段中，服务不能用，可能会导致一部分用户的丢失或投诉等相关问题；如果使用消息队列降解耦后，订单系统只需要把下的订单发送到消息队列中，当其中某个环节在此出现上述的问题时，只需要先把消息存放在消息队列中，等系统修复完成之后，重新监听系统中的消息对消息进行消费操作即可。")]),t._v(" "),s("img",{attrs:{src:t.$withBase("/imgs/duilie.png"),alt:"应用解耦"}}),t._v(" "),s("h2",{attrs:{id:"流量削峰"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#流量削峰"}},[t._v("#")]),t._v(" 流量削峰")]),t._v(" "),s("p",[t._v("        微服务中常见的订单系统为例，假如订单系统每秒钟只能处理10W条订单量，在正常的情况下是没有问题的，突然有一天每秒来了20W的订单需要处理，但是这时已经超出系统能承受的范围了，一般有时候会把订单限制在10W条之内，超出10W的直接做阻断的操作；这种虽然也可以解决，但是对用户可能就不是很友好了。消息队列中的流量削峰的概念可以解决以上出现的问题，用消息队列作为缓冲，当用户操作的时候先把用户的订单信息存放在消息队列中，当流量到达处理的顶峰的时候，可以使用消息堆积的方式，只处理到达顶峰之前的订单，另一部分等处理完成之后再进行处理。")]),t._v(" "),s("h2",{attrs:{id:"mq保证消息的不丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq保证消息的不丢失"}},[t._v("#")]),t._v(" MQ保证消息的不丢失")]),t._v(" "),s("h3",{attrs:{id:"rabbitmq"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[t._v("#")]),t._v(" RabbitMQ")]),t._v(" "),s("p",[t._v("        1、选择MQ提供的事物功能，生产者在发布消息之前开启一个事物，然后进行消息的发送，mq接受到消息后，会自动提交事物，如果mq没有收到成功的消息，会异常报错，进行错误捕获，消息重新发送。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("缺点：效率低下、因为开启了mq的事物，会变成阻塞状态，等待处理结果结束后返回，再进行下一步的处理。")])]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("channel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("txSelect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//开启事物")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//发送消息")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Exection")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      channel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("txRollback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("；"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//回滚事物")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重新提交")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("        2、在生产者哪里设置开启了confirm模式之后，每次写的消息都会分配一个唯一的id，然后如何写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你这个消息发送OK了；如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//开启confirm")]),t._v("\n    channel"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("confirm")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//发送成功回调")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" messageId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      \n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 发送失败回调")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nack")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" messageId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//重发该消息")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h4",{attrs:{id:"消费者弄丢数据解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费者弄丢数据解决方案"}},[t._v("#")]),t._v(" 消费者弄丢数据解决方案")]),t._v(" "),s("p",[t._v("        使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。")]),t._v(" "),s("h3",{attrs:{id:"kafka"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[t._v("#")]),t._v(" kafka")]),t._v(" "),s("h4",{attrs:{id:"消费端丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费端丢失"}},[t._v("#")]),t._v(" 消费端丢失")]),t._v(" "),s("p",[t._v("        1、消费端消息丢失是通过，关闭自定提交offset，在自己处理完毕之后手动提交offset，这样就可以保证消费端的不会把消息弄丢")]),t._v(" "),s("h4",{attrs:{id:"自身消息丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自身消息丢失"}},[t._v("#")]),t._v(" 自身消息丢失")]),t._v(" "),s("p",[t._v("        1、kafka自身消息丢失问题，可以同过设置参数来保证消息的不丢失：\n① 给topic设置 replication.factor参数：这个值必须大于1，表示每个partition必须至少有两个副本；\n②在kafka服务端设置min.isync.replicas参数：这个值必须大于1，表示 要求一个leader至少感知到有至少一个follower在跟自己保持联系正常同步数据，这样才能保证leader挂了之后还有一个follower。\n③在生产者端设置acks=all：表示 要求每条每条数据，必须是写入所有replica副本之后，才能认为是写入成功了\n④在生产者端设置retries=MAX(很大的一个值，表示无限重试)：表示 这个是要求一旦写入事变，就无限重试。")]),t._v(" "),s("h4",{attrs:{id:"生产消息丢失"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产消息丢失"}},[t._v("#")]),t._v(" 生产消息丢失")]),t._v(" "),s("p",[t._v("        如果按照上面设置了ack=all，则一定不会丢失数据，要求是，你的leader接收到消息，所有的follower都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。")]),t._v(" "),s("h2",{attrs:{id:"mq之间的对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq之间的对比"}},[t._v("#")]),t._v(" MQ之间的对比")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("特性")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("ActiveMQ")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("RabbitMQ")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("RocketMQ")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("Kafka")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("API完备性")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高")])]),t._v(" "),s("tr",[s("td",[t._v("多语言支持")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("支持,Java优先")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("语言无关")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("只支持Java")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("支持,Java优先")])]),t._v(" "),s("tr",[s("td",[t._v("单机吞吐量")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("万级")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("万级")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("万级")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("十万级")])]),t._v(" "),s("tr",[s("td",[t._v("消息延迟")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}}),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("微秒级")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("毫秒级")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("毫秒级")])]),t._v(" "),s("tr",[s("td",[t._v("可用性")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("（主从）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("高（主从）")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("非常高（分布式）")])]),t._v(" "),s("tr",[s("td",[t._v("消息丢失")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("低")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("低")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("理论上不会丢失")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("理论上不会丢失")])])])])])}),[],!1,null,null,null);a.default=n.exports}}]);